'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/Blog/posts/crypto/hash/Argon2/','title':"Argon2算法",'section':"Hash",'content':" 本文由 简悦 SimpRead 转码， 原文地址 zhuanlan.zhihu.com\n 这是 Argon2 的参考 C 实现，Argon2 是赢得密码哈希竞赛（PHC）的密码哈希函数。\nArgon2 是一个密码哈希函数，它总结了内存硬函数设计的最新技术，可用于哈希凭证存储、密钥派生或其他应用程序的密码。\n它有着很简单的设计，目的就是达到最高的内存填充率，使用最多的计算单元。同时，它也能抵抗 tradeoff 攻击。（by exploiting the cache and memory organization of the recent processors）\nArgon2 有三个变种：Argon2i, Argon2d, and Argon2id\nArgon2d 是比较快的，被用于数据依赖的内存访问，这使得它对 GPU 破解攻击具有很高的抵抗力，适用于不受侧信道攻击威胁的应用程序（如加密货币）\nArgon2i 使用独立于数据的内存访问，这是密码散列和基于密码的密钥派生的首选方法，但速度较慢，因为它会在内存中进行更多的传递，以防止受到折衷攻击。\nArgon2id 是 Argon2i 和 Argon2d 的混合体，使用依赖于数据和独立于数据的内存访问的组合，这使 Argon2i 能够抵抗侧通道缓存计时攻击，并使 Argon2d 能够抵抗 GPU 破解攻击。\nArgon2i, Argon2d, 和 Argon2id 之间通过参数区分：\n A time cost, which defines the amount of computation realized and therefore the execution time, given in number of iterations A memory cost, which defines the memory usage, given in kibibytes A parallelism degree, which defines the number of parallel threads  https://github.com/P-H-C/phc-winner-argon2​github.com\nArgon2 是一种慢哈希函数，在 2015 年获得 Password Hashing Competition 冠军，利用大量内存计算抵御 GPU 和其他定制硬件的破解，提高哈希结果的安全性。\n 文章主要基于 Argon2 的论文 [1] 和其他一些资料，很可能有理解和表达错误的地方，欢迎指正\n Password #  Password 是 Web 服务主要的认证方式之一。\nPassword 一般以 Hash 后的形式存储在数据库中。这些数据库如果被拖库，使用 Dictionary Attack 可以轻松破解，因为他们的熵很低。相同的密码会被不同的用户使用或同一个用户在不同系统中使用。\n为了解决这个问题，设计者在密码 Hash 的过程里加入了 salt。\n Dictionary Attack 一个字典文件，储存了单词、短语、常用密码和他们 hash 后结果。将密码与 hash 结果对比，就能破解 [2]。\nBrute Force Attack 尝试每一个给定长度下的字符组合，效率很低。\n 加盐已经可以解决大部分问题，但无法阻止 Brute Force Attack，借助 GPU、FPGA、ASIC 等定制硬件可以非常低成本的进行 Hash 计算。此外，如果 salt 和 password 被一起被拖库（甚至代码），会使得破解成本更加低。\n这里核心的问题是，Hash 方法使用的是无内存计算的，而 GPU、ASIC 等硬件可以让无内存计算变得非常高效。但是，当一个 Hash 方法需要用到一大块内存去计算的时候，这些硬件就会束手无策。所以 memory-hard hash function 开始被设计和使用。\nMemory-hard hash function 也可以被用在加密货币的工作量证明中，用来压制 GPU 和 ASIC 在加密货币中的滥用。例如 scrypt 被用作莱特币的工作量证明算法。\n现有的算法的问题 #  要解决密码安全性的问题，一个简单的方法是使用密钥 Hash，例如 HMAC。但是如果设计者更喜欢不是用密钥以防止密钥生成、存储、更新带来的额外问题，那他可以使用 PBKDF2、bcrypt 和 scrpyt。\n这几个算法里只有 scrypt 是以高内存为目标的。但是可以通过 time-space tradeoff 将内存消耗转迁到计算资源消耗上。（scrypt 起初的设计是为了节省 CPU 计算资源，用内存换了计算时间）\n设计一个 memory-hard hash function 是很难的问题。早在 80 年代初期就已经出现这类算法，但实际上都可以被 time-space tradeoff 绕过。攻击者可以将 memory 消耗转换为 time 消耗，然后在高速硬件上使用低内存进行破解。这意味着，攻击者仍然可以实现特制的硬件来破解，即使付出一些额外的代价。\nArgon2 #  Argon2 是 PHC（Password Hashing Competition[3]）的冠军，利用大量内存和大量计算资源进行 Hash 计算。提供三个版本：\n Argon2d：更快，使用 data-dependent 的内存访问方式，data 是需要 Hash 的 password 和 salt。适合加密货币和不会收到 side-channel timing 攻击的应用。 Argon2i：使用 data-independent 的内存访问方式，更适合密码哈希等。他比 Argon2d 慢，因为它需要更多次内存计算（passes）来保护免受 tradeoff 的攻击。 Argon2id：是 Argon2i 和 Argon2d 的混合版本，第一次计算用 Argon2i，后续的计算用 Argon2d。如果没有特定的理由，推荐使用 Argon2id。  Memory-hard hash function 的定义 #  使用 time-area 复杂度衡量，面积指的是电路板上的元件个数，增加元件个数可以减少运算的时间，所以可以使用面积乘以时间作为复合评价尺度。\n我们将攻击者使用的 ASIC 上内存大小对应为面积 A，运行时长为 T。\nHash 算法（H）的目标是令 A*T 最大化\n假设攻击者想降低内存的使用，只使用 αM 的内存来计算 H（α \u0026lt; 1）。\n对 H 使用 time-space tradeoff 的方法，它需要多花 C(α) 倍计算成本，而它的计算时间至少增加了 D(α) 倍。因此，在 time-area 乘积里，可能的最大增益 ε 为\n拿前后两个 AT 乘积相比，定义为增益。攻击者的目的是要让分母尽可能的小，也就是 ε 尽可能的大。因此，最大收益就是上面列出的公式。\n一个算法被称为 memory-hard hash function 需要满足\nD(α) \u0026gt; 1/α，α 趋近于 0\n只有这样，在攻击者减少内存的时候，最大收益 ε \u0026lt; 1，也就是说减少内存时的 AT 复杂度不会降低。\n除此之外，AT 值还会受到以下几个因素影响：\n 计算资源因为内存减少而产生的惩罚 C(α) 可能会显著增加面积 A 如果 tradeoff 需要显著依赖计算资源之间的通信，那内存带宽的限制会对运行时间增加额外的限制  Argon2 的实现 #  输入 #  Primary inputs 是 message P 和 nonce S，代表密码和盐。\nSecondary inputs 有\n 并行程度 p Tag length τ, 代表期望返回的结果长度 bytes 内存大小 m kilobytes 迭代次数 t，用于调节运行时间，与内存大小独立 version number v secret value K，默认没有 key associated data X Type y of Argon2, 0 代表 Argon2d, 1 代表 Argon2i, 2 代表 Argon2id  运算 #  首先，给 P 和 S 做哈希，所有其他参数也被加入，变量 P、S、K、X 的长度被放置在他们前面。\nH 是 Blake2b[4]\n然后 Argon2 用 m\u0026rsquo; 个 block 填满内存\nm\u0026rsquo; = m/4p 向下取整后 * 4p\n为了方便调整并行线程数 p，内存组织以 B[i][j] 形式的 matrix 存储。有 p 行，q = m\u0026rsquo;/p 列。我们用以下形式，表示第 t 个 pass 里的 block\n其中，\n block index [i\u0026rsquo;][j\u0026rsquo;] 根据使用的 Argon2d 或 Argon2i 而不同，结果可能是除了当前 slice 里的其他所有 block（下面图上跨 lane 的那几个虚线） G 是排列组合函数，基于 Blake2b 的 round function 改进而来 H\u0026rsquo; 是长度可变的、在 H 的基础上实现的哈希函数  如果 t\u0026gt;1, 我们需要重复处理过程，我们用新的 block XOR 老的 block 得出\n当我们完成 t 次迭代后，我们计算最终的 block B_final，为最后一列所有值的异或\n最后，对 B_final 运算 H‘ 函数，完成最终的输出 Tag\nFeatures #   性能。Argon2 填充内存的速度非常快，从而增加了 AT 里的 A。Argon2i 对每个 byte 稳定占用 2 个 CPU cycles，Argon2d 就快 3 倍。 Tradeoff 抵御能力。默认 passes 配置下（Argon2d 为 1，Argon2i 为 3），ASIC 设备在减少至 α =1/4 或更少内存的时候，无法减少 time-area 复杂度。如果把 pass 数量提高，时间惩罚会更高。 可扩展性。Argon2 可以同时在时间和内存两个维度扩展，两者互相独立，保证始终能在一定数量的时间内填满一定数量的内存。 并行。Argon2 最多可以使用 2^24 个并发线程。在实验中，8 个线程就已经消耗完了所有的计算资源和带宽。 GPU/FPGA/ASIC-unfriendly。Argon2 对 x86 做了高度优化，所以在定制硬件下运行既不会更快也不会更便宜。 支持额外的输入。除了 message 和 nonce，类似 secret key，环境变量，用户数据等内容也可以被输入作为参数。  安全性分析 #  Tradeoff attack #  结论是，data-dependent one-pass 的情况得下，攻击者可以在降低内存 3 倍的情况下，保持 time-area 复杂度不变。具体的表\n上面已经说过，需要满足 D(α) \u0026gt; 1/α，α 趋近于 0，一个函数才能称为 memory-hard hash function\n在论文发布后，有两次公开的对 Argon2i 的破解 [5]。作者发布了更新版本，并做了 summary\n 针对 1- 和 2-pass Argon2i(v1.3) 可以减少 time-area 复杂度至 α = 1/5 针对 t-pass(t\u0026gt;2) 的 Argon2i，time-area 复杂度可以减少至 α = 1/3 针对 t-pass Argon2d，time-area 复杂度可以减少至 α = 1/1.33  论文里还有更多针对内存优化攻击、迭代次数压缩攻击和通用攻击的具体分析，这里不展开了\n更多的细节和内容推荐阅读代码 [6] 和论文\n"});index.add({'id':1,'href':'/Blog/posts/crypto/ecc/Curve25519/','title':"Curve曲线算法",'section':"Ecc",'content':"Curve25519/Ed25519/X25519 是著名密码学家 Daniel J. Bernstein 在 2006 年独立设计的椭圆曲线加密 / 签名 / 密钥交换算法，和现有的任何椭圆曲线算法都完全独立，其中 Ed25519 用于签名，可在区块链中进行签名，Stellar 就是使用了 Ed25519 作为签名算法的。\nDaniel J. Bernstein 是世界著名的密码学家，他在大学曾经开设过一门 UNIX 系统安全的课程给学生，结果一学期下来，发现了 UNIX 程序中的 91 个安全漏洞；他早年在美国依然禁止出口加密算法时，曾因为把自己设计的加密算法发布到网上遭到了美国政府的起诉，他本人抗争六年，最后美国政府撤销所有指控，目前另一个非常火的高性能安全流密码 ChaCha20 也是出自 Bernstein 之手。\n25519 系列曲线自 2006 年发表以来，除了学术界无人问津， 2013 年爱德华 · 斯诺登曝光棱镜计划后，该算法突然大火，大量软件，如 OpenSSH 都迅速增加了对 25519 系列的支持，如今 25519 已经是大势所趋，可疑的 NIST 曲线迟早要退出椭圆曲线的历史舞台，目前， RFC 增加了 SSL/TLS 对 X25519 密钥交换协议的支持，而新版 OpenSSL 1.1 也加入支持，是摆脱老大哥的第一步，下一步是将 Ed25519 做为可选的 TLS 证书签名算法，彻底摆脱 NIST 。\nCurve25519 是目前最高水平的 Diffie-Hellman 函数，适用于广泛的场景，由 Daniel J. Bernstein 教授设计。在密码学中，Curve25519 是一个椭圆曲线提供 128 位安全性，设计用于椭圆曲线 Diffie-Hellman（ECDH）密钥协商方案。它是最快的 ECC 曲线之一，并未被任何已知专利所涵盖。\nEd25519 是一个数字签名算法，签名和验证的性能都极高， 一个 4 核 2.4GHz 的 Westmere cpu，每秒可以验证 71000 个签名，安全性极高，等价于 RSA 约 3000-bit。签名过程不依赖随机数生成器，不依赖 hash 函数的防碰撞性，没有时间通道攻击的问题，并且签名很小，只有 64 字节，公钥也很小，只有 32 字节。\n根据其网站介绍，Ed25519 算法具有以下优势：\n  完全开放设计，算法各参数的选择直截了当，非常明确，没有任何可疑之处，相比之下目前广泛使用的椭圆曲线是 NIST 系列标准，方程的系数是使用来历不明的随机种子 c49d3608 86e70493 6a6678e1 139d26b7 819f7e90 生成的，至于这个种子的来历没有资料介绍；\n  安全性高，一个椭圆曲线加密算法就算在数学上是安全的，在实用上也并不一定安全，有很大的概率通过缓存、时间、恶意输入摧毁安全性，而 25519 系列椭圆曲线经过特别设计，尽可能的将出错的概率降到了最低，可以说是实践上最安全的加密算法。例如，任何一个 32 位随机数都是一个合法的 X25519 公钥，因此通过恶意数值攻击是不可能的，算法在设计的时候刻意避免的某些分支操作，这样在编程的时候可以不使用 if ，减少了不同 if 分支代码执行时间不同的时序攻击概率，相反， NIST 系列椭圆曲线算法在实际应用中出错的可能性非常大，而且对于某些理论攻击的免疫能力不高， Bernstein 对市面上所有的加密算法使用 12 个标准进行了考察， 25519 是几乎唯一满足这些标准的.\n  以下是评价的截图，\n更多可以查看网站\n25519 曲线和 ECC 曲线的联系和区别是什么? #  Curve25519（X25519）是进行蒙哥马利曲线（Montgomery Curve）迪菲赫尔曼秘钥交换的椭圆曲线算法。Ed25519 是进行爱德华曲线（Edwards Curve）数字签名的椭圆曲线算法。\n25519 曲线与其他 ECC 曲线是否兼容？ #  25519 曲线与 SECG（Standards for Efficient Cryptography Group）工作组所指定的魏尔斯特拉斯曲线（Weierstrass Curve）在曲线的公式上有所不同，因此他们不兼容。 蒙哥马利曲线和爱德华曲线的算法，能做到 “Time-constant”，也就是说不论他们进行运算的数值是多少，他们所花的时间是相同的，因此 “时间旁路”（Time side channel）攻击就对它们无效。\nopenssl 是否支持 25519 曲线? #  支持\n如何生成 Curve25519 椭圆曲线密钥（该密钥专门用于 ECDH 密钥协商）？ #  $ openssl genpkey -algorithm X25519 -out xkey.pem 如何生成 Ed25519 椭圆曲线签名密钥（专用于数字签名）? #  $ openssl genpkey -algorithm ED25519 -out xkey.pem "});index.add({'id':2,'href':'/Blog/posts/crypto/ecc/ECIES-Example/','title':"ECIES加密方案",'section':"Ecc",'content':" 本文由 简悦 SimpRead 转码， 原文地址 cryptobook.nakov.com\n 在许多加密标准（例如SECG SEC-1，ISO / IEC 18033-2，IEEE 1363a和ANSI X9.63）中，类似于先前演示的代码的混合加密方案以椭圆曲线集成加密方案（ECIES）的名称进行了标准化。ECIES是一种经过公钥认证的加密方案，其工作原理与上述代码示例相似，但使用KDF（密钥派生功能）从ECDH共享机密派生单独的MAC密钥和对称加密密钥。它有许多变体。\n的ECIES标准结合了基于ECC-非对称加密与对称密码通过由相应的EC公共密钥EC专用密钥和解密，以提供数据加密。的ECIES加密方案使用ECC加密（公开密钥密码系统）+密钥推导函数（KDF）+对称加密算法+ MAC算法，组合在一起像它在如下图所示：\nECIES加密的输入由收件人的公钥+纯文本消息组成。输出包括发件人的临时公共密钥（密文公共密钥）+加密的消息（密文+对称算法参数）+身份验证标签（MAC代码）：\n ECIES-encrypt(recipientPublicKey, plaintextMessage) ➔ { cipherTextPublicKey, encryptedMessage, authTag }  的ECIES解密需要从加密+的输出接收者的私有密钥，并且产生原始明文消息或检测到问题（例如完整性/验证错误）：\n ECIES-decrypt(cipherTextPublicKey, encryptedMessage, authTag, recipientPrivateKey, ) ➔ plaintextMessage  ECIES加密方案是一个框架，而不是一个具体的算法。它可以通过插入不同的算法来实现，例如用于公钥计算的secp256k1或P-521椭圆曲线+用于KDF函数的PBKDF2或Scrypt +用于对称密码和身份验证标签的AES-CTR或AES-GCM或ChaCha20-Poly1305 +用于MAC算法的HMAC-SHA512（如果使用未经身份验证的加密）。\n在下一节中，我们将通过代码示例演示如何在实践中使用ECIES。\n"});index.add({'id':3,'href':'/Blog/posts/crypto/ecc/ECIES-Wiki/','title':"ECIES加密概要",'section':"Ecc",'content':" 原文地址 en.wikipedia.org\n 集成加密方案（IES）一种的英文混合加密方案，柯林斯为网求允许使用选定明文状语从句：选定密文攻击的对手提供语义安全性。该方案的安全性基于计算的的Diffie-Hellman问题。IES的两个版本已标准化：离散对数集成加密方案（DLIES）和椭圆曲线集成加密方案（ECIES），也称为椭圆曲线增强加密方案或简称为椭圆曲线加密方案。这两个化身在更大人群的变化之前都是相同的，因此，具体而言，我们将重点放在后者上。\n非正式描述 #  作为IES工作原理的_简要和非正式_描述和概述，我们使用基于离散对数集成加密方案（DLIES）的示例，重点是可以吸引读者的理解，而不是精确的技术细节。\n 爱丽丝学到鲍勃的公钥，。 爱丽丝产生新的短暂价值 相关相关的公共价值， 。 然后，爱丽丝计算对称密钥 使用此信息和密钥派生函数KDF如下：。 爱丽丝计算她的密文 从她的实际信息 ，即的对称加密 ，在密钥下加密 （使用经过身份验证的加密方案），如下所示：。 爱丽丝（在一条消息中）同时发送公共临时消息 和密文 。 鲍勃，知道 和 ，现在可以计算 并解密 从 。  请注意，该方案无法确保Bob确实确定了谁真正发送了消息：该方案并没有阻止任何人假装成Alice。\n形式描述 #  所需信息 #  要使用ECIES将加密的消息发送给Bob，Alice需要以下信息：\n 要使用的密码套件，包括密钥派生功能（例如，具有SHA-1选项的ANSI-X9.63-KDF），消息身份验证代码（例如，具有160位密钥的HMAC-SHA-1-160_或_HMAC- SHA-1-80，用80位密钥）和对称加密方案（例如，TDEA在CBC模式_或_XOR加密方案）-; 椭圆曲线域参数： 为素数场上的曲线或 为二进制二进制上的曲线； 鲍勃的公钥： （鲍勃生成它如下： ，在哪里 是他随机选择的私钥： ）； 任选的共享信息： 和 。 表示无穷大的点  加密 #  加密消息 爱丽丝执行以下操作：\n 产生一个随机数 并计算 ; 引发一个共享的秘密： ，在哪里 （和 ）； 使用KDF更新对称加密密钥和MAC密钥：; 加密消息： ; 计算加密消息的标签，然后 ： ; 输出 。  解密 #  解密密文 鲍勃执行以下操作：\n 得出共享的秘密： ，在哪里 （它与爱丽丝衍生的那张相同，因为 ; 派生密钥的方式与Alice相同： ; 使用MAC来检查变量和输出_失败_如果; 使用对称加密方案解密消息 。  参考 #   Victor Shoup，公开密钥加密的ISO标准规范，版本2.1，2001年12月20日。 Certicom研究中心，《高效密码技术的标准》，SEC 1：椭圆曲线密码技术，版本2.0，2009年5月21日。 GayosoMartínez，埃尔南德斯·恩西纳斯，桑切斯·阿维拉：椭圆曲线集成加密方案的调查，计算机科学与工程学报，2010年2月2日，第7-13页。 Ladar Levison：使用ECIES保护数据的代码（ECC + AES + SHA），openssl-devel邮件列表，2010年8月6日。 Abdalla，Michel和Bellare，Mihir和Rogaway，Phillip：DHIES：基于Diffie-Hellman问题的加密方案，IACR密码学ePrint档案，1999年。  贝纳洛百隆–金华瑟Cayley–PurserDamgård–JurikGMR戈德华瑟–米卡利Naccache–Stern佩里耶拉宾RSA冈本–内山施密特–萨摩亚离散对数劳工统计局克莱默–肖普DHDSA曲线25519ECDHECDSA教育局合格证书KE埃尔加马尔签名方案MQV施诺尔说话建议零售价STS莱迪思/ SVP / CVP / LWE / SISNTRUEncryptNTRUSignRLWE-KEXRLWE-SIG极乐新希望其他自动曝光塞利迪EPOCHFEIES兰波特麦克里斯默克尔·赫尔曼Naccache–Stern背包密码系统三遍协议XTR理论上离散对数椭圆曲线密码学非交换密码学RSA问题活板门功能标准化加密记录IEEE P1363内西NSA Suite B量子后密码学标准化主题电子签名OAEP指纹公钥基础设施信任网关键大小基于身份的加密后量子密码学OpenPGP卡 | 节目  v Ť Ë     密码学          密码学的历史 密码分析 密码学概述  | |\n 对称密钥算法 分组密码 流密码 公钥加密 加密哈希函数 消息验证码 随机数 隐写术  | |\n 类别  |\nNewPP限制报告，由mw1392解析缓存时间：20210111130647缓存过期：2592000动态内容：false并发症：[] CPU使用时间：0.228秒实时使用时间：0.395秒预处理器访问的节点数：770/1000000扩展后包含大小：96087 / 2097152字节模板参数大小：6538/2097152字节最高扩展深度：19/40昂贵的解析器功能计数：3/500 Unstrip递归深度：0/20 Unstrip展开后大小：3736/5000000字节Lua使用时间：0.075 / 10.000秒Lua内存使用情况：1960159/52428800字节已加载的Wikibase实体数：0/400\n包含扩展时间报告（％，ms，calls，template）100.00％189.312 1-总计70.20％132.891 5 Template：Navbox 65.13％123.299 3 Template：Ambox 62.56％118.434 1 Template：Multiple_issues 35.48％67.175 1 Template：Cryptography_navbox 18.35％34.736 1模板：引文风格14.66％27.757 1模板：密码学公钥11.40％21.590 1模板：无脚注4.27％8.092 1模板：图标3.47％6.578 2模板：是\n使用关键enwiki：pcache：idhash：3530076-0！canonical！math = 5和时间戳20210111130646和修订版ID 913865821保存在解析器缓存中。使用JSON序列化。\n"});index.add({'id':4,'href':'/Blog/posts/crypto/Signal/','title':"Signal算法白皮书",'section':"Crypto",'content':" 本文由 简悦 SimpRead 转码， 原文地址 blog.lancitou.net\n 本文是 Signal 协议中使用的「双棘轮算法」的中文翻译（基于 Revision 1, 2016-11-20),「参考资料」部分保持原文不翻译，英文原文在此。\n双棘轮算法用于通信双方基于共享密钥交换加密消息。通常，通信双方将先使用某种密钥协商协议（例如 X3DH1）以协商共享密钥。此后，通信双方即可使用双棘轮算法发送接收加密消息了。\n通信双方将为每一个双棘轮消息派生出新的密钥，使得旧的密钥不能从新的密钥计算得到。通信双方还将在消息中附上迪菲 - 赫尔曼公钥值。迪菲 - 赫尔曼计算的结果将被混入派生出的密钥中，使得新的密钥不能从旧的密钥计算得到。这些特性将在某一方的密钥泄漏后保护此前或此后的加密消息。\n下面描述双棘轮算法及其带头部加密的变种，同时将讨论二者的安全特性。\n2.1. KDF 链 #  KDF 链是双棘轮算法中的核心概念。\n我们将 KDF 定义为这样一个密码学函数：输入一个秘密且随机的 KDF 密钥（KDF key） 及其它一些输入数据，并返回输出数据。在密钥未知的前提下，输出的数据与随机数不可区分（也就是说，KDF 满足密码学「PRF」的要求）。若密钥不是秘密且随机的，则 KDF 应仍然能作为密钥和输入数据的安全的密码学哈希。当 HMAC 和 HKDF 使用安全的哈希算法实例化时，二者的构造即满足 KDF 定义 23。\n我们使用术语 KDF 链表示如下流程：一个 KDF 输出的一部分作为 输出密钥（Output key），而另一部分将取代 KDF 密钥，作为另一个 KDF 的输入密钥。下图展示了一个处理三个输入密钥并生成三个输出密钥的 KDF 链：\n一个 KDF 链具有如下特性（使用的术语来自 4）：\n 弹性（resilience）：对于不知道 KDF 密钥的攻击者来说，输出密钥看起来是随机的。即使攻击者能控制 KDF 的输入，此条特性仍然成立。 前向安全性（forward security）：对于知道某一时刻的 KDF 密钥的攻击者来说，旧的输出密钥看起来是随机的。 被攻破后的可恢复性（break-in recovery）：对于知道某一时刻的 KDF 密钥的攻击者来说，新的输出密钥看起来是随机的，只要新的输入中增加了足够的熵（entropy）。  在 Alice 和 Bob 之间的双棘轮会话中，双方保存的 KDF 密钥将用于三条链：根链（root chain）、发送链（sending chain）及接收链（receiving chain）（Alice 的发送链对应 Bob 的接收链，反之亦然）。\nAlice 和 Bob 交换消息的同时，也交换新的迪菲 - 赫尔曼公钥，而迪菲 - 赫尔曼输出的密钥将作为根链的输入。根链输出的密钥将作为发送链和接收链的 KDF 密钥。这称为迪菲 - 赫尔曼棘轮（Diffie-Hellman ratchet）。\n每发送和接收一条消息，发送链和接收链都将向前推进。相应的输出密钥将用于加密和解密消息。这称为对称密钥棘轮（symmetric-key ratchet）。\n后继几节将更详细地解释对称密钥棘轮和迪菲 - 赫尔曼棘轮，之后将描述二者如何组合成为双棘轮。\n2.2. 对称密钥棘轮 #  每条发送或接收的消息都使用一个唯一的消息密钥（message key）加密。消息密钥是发送 KDF 链和接收 KDF 链的输出密钥。这些链的 KDF 密钥称为链密钥（chain key）。\n由于发送链和接收链的 KDF 输入是常数，所以这两条链不具备被攻破后的可恢复性。发送链和接收链只能确保每条消息使用唯一的密钥加密，而此密钥在加密或解密后可以删除。由一个给定的链密钥计算下一个链密钥和消息密钥的过程，称为对称密钥棘轮（symmetric-key ratchet）的一次棘轮步进（ratchet step）。下图展示了两次步进：\n由于消息密钥不用于派生其它密钥，因此可以保存起来而不影响其它消息密钥的安全性。这将有助于处理消息的丢失或乱序（参见第 2.5 节）。\n2.3. 迪菲 - 赫尔曼棘轮 #  如果中间攻击者窃取了其中一方的发送链密钥和接收链密钥，那么他可以计算此后所有的消息密钥，并解密对应的消息。为了避免这种情况，双棘轮算法将对称密钥棘轮与 DH 棘轮组成在一起，使用后者基于迪菲 - 赫尔曼的输出更新链密钥。\n为了实现 DH 棘轮，通信双方各自生成一个 DH 密钥对（迪菲 - 赫尔曼公钥和私钥）作为当前的棘轮密钥对（ratchet key pair）。从任意一方发出的每一条消息都将携带一个消息头，其中包含发送者当前的棘轮公钥。当接收到远端发送过来的新的棘轮公钥时，本端将实施一次 DH 棘轮步进（DH ratchet step），生成一个新的棘轮密钥对以取代本端当前的密钥对。\n通信双方交替地更新棘轮密钥对，使之形成一个「乒乓」行为模式。仅截获了其中一方的窃听者可能得到当前棘轮私钥的值，但此棘轮私钥将最终被未泄露的棘轮私钥取代。那时，棘轮密钥对之间的迪菲 - 赫尔曼计算将定义一个对攻击者未知的新的 DH 输出。\n以下几张图展示了 DH 棘轮如何派生出一系列共享的 DH 输出。\nAlice 使用 Bob 的棘轮公钥初始化，而 Bob 尚未得知 Alice 的棘轮公钥。作为初始化的一部分，Alice 使用她自己的棘轮私钥和 Bob 的棘轮公钥作 DH 运算：\nAlice 的初始消息宣告了其棘轮公钥。一旦 Bob 收到其中一条初始消息，Bob 就执行一次 DH 棘轮步进：他使用 Alice 的棘轮公钥和自己的棘轮私钥作 DH 运算，得到的结果应与 Alice 的初始 DH 输出相等。之后 Bob 替换掉自己的棘轮密钥对并重新计算一个新的 DH 输出：\nBob 发送的消息宣告了其新的公钥。最终，Alice 将收到其中一条消息并执行一次 DH 棘轮步进，替换自己的棘轮密钥对并派生出两个 DH 输出，一个与 Bob 的最新 DH 输出相等，另一个为新的 DH 输出：\nAlice 发送的消息宣告了其新的公钥。最终，Bob 将收到其中一条消息并执行第二次 DH 棘轮步进，如此反复：\n每一次 DH 棘轮步进生成的 DH 输出，用于派生新的发送链密钥和接收链密钥。下图重新展示了 Bob 的第一次棘轮步进。Bob 使用其第一个 DH 输出派生出接收链，与 Alice 的发送链对应。Bob 使用第二个 DH 输出派生新的发送链：\n当双方交替执行 DH 棘轮步进的同时，也交替地引入新的发送链：\n然而，上图是经过简化的版本。实际上并不是直接将 DH 输出作为链密钥，而是将 DH 输出作为根链的 KDF 输入，而根链的 KDF 输出作为发送链密钥和接收链密钥。此处使用 KDF 链改进了算法的弹性和被攻破后的可恢复性。\n所以一次完整的 DH 棘轮步进包括两次根 KDF 链的更新，并将其 KDF 输出分别作为新的接收链密钥和发送链密钥：\n2.4. 双棘轮 #  将对称密钥棘轮和 DH 棘轮组合在一起，形成了双棘轮：\n 当发送或接收消息时，执行一次发送链或接收链的对称密钥棘轮步进，以派生新的消息密钥。 当接收到新的棘轮公钥时，在对称密钥棘轮步进之前，执行一次 DH 棘轮步进，以更新链密钥。  下图中，Alice 已使用 Bob 的棘轮公钥及作为初始根密钥（ RK ）的共享密钥初始化。作为初始化的一部分，Alice 生成一个新的棘轮密钥对，并将 DH 输出作为根 KDF 的输入，计算出新的根密钥（ RK ）和发送链密钥（ CK ）：\n当 Alice 发送第一条消息 A1 时，她对发送链密钥执行一次对称密钥棘轮步进，以生成新的消息密钥（消息密钥以其加密或解密的消息编号标注）。新的链密钥将保存起来，但消息密钥和旧的链密钥可以删除：\n假如接下来 Alice 收到 Bob 发送的响应消息 B1 ，其中包含 Bob 的新的棘轮公钥（Bob 的公钥以其所在的首条消息编号标注）。Alice 执行一次 DH 棘轮步进，以派生新的接收链密钥和发送链密钥。之后她对接收链执行一次对称密钥棘轮步进，以获取接收到的消息对应的消息密钥：\n假设接下来 Alice 发送了消息 A2 ，接收到包含 Bob 旧的棘轮公钥的消息 B2 ，接着又发送了消息 A3 和 A4 。Alice 的发送链将步进三次，而其接收链仅步进一次：\n假设接下来 Alice 接收到包含 Bob 新的棘轮公钥的消息 B3 和 B4 ，并发送了消息 A5 。Alice 的最终状态如下：\n2.5. 乱序消息 #  双棘轮算法处理消息丢失或乱序的方法是：在每个消息头部包含此消息在发送链中的编号（_N_=0,1,2,…）以及之前的发送链的长度（ PN ，即消息密钥的个数）。这使接收方可以保存被跳过的消息密钥而跳转到对应的消息密钥，而当被跳过的消息到达时可使用保存的消息密钥解密。\n当接收到一条消息时，如果触发了 DH 棘轮步进，那么接收到的 PN 减掉当前接收链的长度就是此接收链中被跳过的消息数目。接收到的 N 是新的接收链（即 DH 棘轮步进之后的接收链）中被跳过的消息数目。\n如果没有触发 DH 棘轮步进，那么接收到的 N 减掉当前接收链的长度就是此接收链中被跳过的消息数目。\n例如，假设上一节的消息序列中，消息 B2 和 B3 被跳过。消息 B4 将触发 Alice 的 DH 棘轮步进（不乱序时本应由 B3 触发）。消息 B4 的 _PN_=2，_N_=1。当接收到 B4 时，Alice 的接收链长度为 1（ B1 ），所以 Alice 将 B2 和 B3 的消息密钥保存，以便之后接收到这两个消息时可以对其解密：\n3.1. 外部函数 #  为了实例化双棘轮算法，还需要定义以下的函数。推荐的算法请参见第 5.2 节。\n GENERATE_DH()：返回新的迪菲 - 赫尔曼密钥对。 DH(dh_pair, dh_pub)：返回 DH 密钥对 dh_pair 中的私钥与 DH 公钥 dh_pub 的迪菲 - 赫尔曼运算结果。如果 DH 函数拒绝无效的公钥，那么此函数可能发生异常并终止处理。 KDF_RK(rk, dh_out)：此函数将 32 字节的根密钥 rk 及迪菲 - 赫尔曼输出 dh_out 作为 KDF 的输入，并返回二元组：新的 32 字节根密钥及 32 字节链密钥。 KDF_CK(ck)：此函数将 32 字节链密钥 ck 及某个常量作为 KDF 的输入，并返回二元组：新的 32 字节链密钥及 32 字节消息密钥。 ENCRYPT(mk, plaintext, associated_data)：此函数返回使用消息密钥 mk5 对明文 plaintext 做 AEAD 加密的结果。附加数据 associated_data 经过认证但不包含在密文中。由于每个消息密钥只使用一次，因此 AEAD 的 nonce 值可以有多种不同的处理方式：固定为一个常数；使用另外的 AEAD 加密密钥从 mk 派生；从 KDF_CK() 的额外输出中派生；或者随机选择并发送。 DECRYPT(mk, ciphertext, associated_data)：此函数返回使用消息密钥 mk 对密文 ciphertext 做 AEAD 解密的结果。如果认证失败，将发生异常并终止处理。 HEADER(dh_pair, pn, n)：由密钥对 dh_pair 、之前的链长度 pn 及消息数目 n 生成包含 DH 棘轮公钥的消息头。返回的消息头包含棘轮公钥 dh 及整数 pn 和 n 。 CONCAT(ad, header)：将消息头部编码成可解析的字节序列，并在前面附上字节序列 ad 并返回结果。如果不能保证 ad 是可解析的字节序列，将用其长度值取代 ad 本身附加在消息头前面，使得此函数输出的总是可解析且唯一的二元组 (ad, header)。  同时需要定义一个 MAX_SKIP 常量。此常量指定了在同一个链中最多可跳过的消息密钥的个数。此常量的值需要足够大以便允许消息的常规丢失或延迟，但又需要足够小以避免恶意的发送者消耗接收者过多的计算资源。\n3.2. 状态变量 #  通信双方都将跟踪如下的状态变量：\n DHs：DH 棘轮密钥对（「发送」密钥或「本端」密钥） DHr：DH 棘轮公钥（「接收」密钥或「远端」密钥） RK：32 字节的根密钥 CKs, CKr：发送链密钥和接收链密钥，均为 32 字节 Ns, Nr：发送链及接收链的消息数目 PN：之前的发送链的消息数目 MKSKIPPED：已跳过的消息密钥的字典，由棘轮公钥和消息编号索引。若保存了过多的元素则发生异常。  在下文的 Python 代码中，状态变量将作为一个 state 对象的成员被访问。\n3.3. 初始化 #  在初始化之前，双方必须使用某种密钥协商协议以协商出一个 32 字节的共享密钥 SK 及 Bob 的棘轮公钥。这些值将用于生成 Alice 的发送链密钥及 Bob 的根密钥。而 Bob 的（发送及接收）链密钥及 Alice 的接收链密钥暂时留空，将由各自的首次 DH 棘轮步进操作初始化。\n（此处假设 Alice 先发送消息，而 Bob 直到接收到 Alice 的某条消息之后才发送消息。为允许 Bob 在初始化后也能立即发送消息，Bob 的发送链密钥及 Alice 的接收链密钥也需要初始化为一个共享密钥。为简单起见，我们不再考虑此场景。）\n一旦 Alice 和 Bob 协商好了 SK 及 Bob 的棘轮公钥，Alice 调用 RatchetInitAlice() ，而 Bob 调用 RatchetInitBob() ：\ndef RatchetInitAlice(state, SK, bob_dh_public_key): state.DHs = GENERATE_DH() state.DHr = bob_dh_public_key state.RK, state.CKs = KDF_RK(SK, DH(state.DHs, state.DHr)) state.CKr = None state.Ns = 0 state.Nr = 0 state.PN = 0 state.MKSKIPPED = {} def RatchetInitBob(state, SK, bob_dh_key_pair): state.DHs = bob_dh_key_pair state.DHr = None state.RK = SK state.CKs = None state.CKr = None state.Ns = 0 state.Nr = 0 state.PN = 0 state.MKSKIPPED = {} 3.4. 加密消息 #  调用 RatchetEncrypt() 以加密消息。此函数执行一次对称密钥棘轮步进，并使用生成的消息密钥加密消息。除了消息明文 plaintext 之外，此函数还需要一个字节序列 AD 附加在消息头前面，以形成底层 AEAD 加密所需的附加数据：\ndef RatchetEncrypt(state, plaintext, AD): state.CKs, mk = KDF_CK(state.CKs) header = HEADER(state.DHs, state.PN, state.Ns) state.Ns += 1 return header, ENCRYPT(mk, plaintext, CONCAT(AD, header)) 3.5. 解密消息 #  调用 RatchetDecrypt() 以解密消息。此函数完成如下操作：\n 如果消息对应一个被跳过的消息密钥，此函数使用对应的消息密钥解密消息，删除消息密钥后返回。 否则，如果接收到新的棘轮密钥，此函数保存当前接收链上所有被跳过的消息密钥，并执行一次 DH 棘轮步进以取代发送链和接收链。 之后，此函数执行一次对称密钥棘轮步进，以派生对应的消息密钥及下一个链密钥，并解密消息。  如果发生异常（例如消息认证失败），则消息被丢弃，对状态对象的修改也同时被丢弃。否则，接受解密后的明文并保存对状态对象的修改：\ndef RatchetDecrypt(state, header, ciphertext, AD): plaintext = TrySkippedMessageKeys(state, header, ciphertext, AD) if plaintext != None: return plaintext if header.dh != state.DHr: SkipMessageKeys(state, header.pn) DHRatchet(state, header) SkipMessageKeys(state, header.n) state.CKr, mk = KDF_CK(state.CKr) state.Nr += 1 return DECRYPT(mk, ciphertext, CONCAT(AD, header)) def TrySkippedMessageKeys(state, header, ciphertext, AD): if (header.dh, header.n) in state.MKSKIPPED: mk = state.MKSKIPPED[header.dh, header.n] del state.MKSKIPPED[header.dh, header.n] return DECRYPT(mk, ciphertext, CONCAT(AD, header)) else: return None def SkipMessageKeys(state, until): if state.Nr + MAX_SKIP \u0026lt; until: raise Error() if state.CKr != None: while state.Nr \u0026lt; until: state.CKr, mk = KDF_CK(state.CKr) state.MKSKIPPED[state.DHr, state.Nr] = mk state.Nr += 1 def DHRatchet(state, header): state.PN = state.Ns state.Ns = 0 state.Nr = 0 state.DHr = header.dh state.RK, state.CKr = KDF_RK(state.RK, DH(state.DHs, state.DHr)) state.DHs = GENERATE_DH() state.RK, state.CKs = KDF_RK(state.RK, DH(state.DHs, state.DHr)) 4.1. 概述 #  本节介绍双棘轮算法的头部加密（header encryption） 变种。\n消息头部包含棘轮公钥及 (PN, N) 值。在某些场景下，可能需要对头部也加密，以使监听者无法区分哪个消息属于哪个会话，或某个会话中消息的顺序。\n使用头部加密，通信双方需要为发送和接收两个方向都保存一个对称的头部密钥（header key）及下一个头部密钥（next header key）。发送头部密钥用于当前发送链的头部加密。\n当接收者收到一条消息时，她必须首先将消息关联到对应的双棘轮会话（假设她与多方同时保持多个会话）。如何关联不在本文讨论范围内，读者可参考 Pond 协议 6。\n将消息与会话关联之后，接收者依次尝试使用此会话中接收链的头部密钥、下一个头部密钥及与被跳过的消息对应的所有头部密钥对消息头解密。若使用下一个头部密钥解密成功，则表示接收者必须执行一次 DH 棘轮步进。在 DH 棘轮步进过程中，下一个头部密钥取代当前头部密钥，而根 KDF 的额外输出作为新的下一个头部密钥。\n下图中，Alice 已使用 Bob 的棘轮公钥及初始根密钥（ RK ）、发送头部密钥（ HK ）、下一个接收头部密钥（ NHK ）作为共享密钥初始化。作为初始化的一部分，Alice 生成其棘轮密钥对并更新根链以派生新的根密钥（ RK ）、发送链密钥（ CK ）及下一个发送头部密钥（ NHK ）：\n当 Alice 发送第一个消息 A1 时，她使用已初始化的发送头部密钥对消息头加密：\n假如接下来 Alice 收到来自 Bob 的响应消息 B1 ，此消息的头部将使用已初始化的下一个接收头部密钥加密。Alice 执行一次 DH 棘轮步进，使得下一个头部密钥成为当前头部密钥，并生成新的下一个头部密钥：\n接下来 Alice 发送消息 A2 ，并接收消息 B2 ，此消息可使用当前接收头部密钥解密，并包含与消息 B1 相同的棘轮公钥。之后 Alice 发送消息 A3 和 A4 。当前头部密钥用于此阶段所有发送和接收的消息：\n此后 Alice 收到消息 B3 ，其中包含 Bob 新的棘轮密钥，且消息头部使用下一个接收头部密钥加密。使用下一个头部密钥对消息头成功解密后，将触发一次 DH 棘轮步进。接着 Alice 收到使用（与 B3 ）相同的棘轮密钥和头部密钥的消息 B4 ，再发送消息 A5 。Alice 的最终状态如下所示：\n4.2. 外部函数 #  头部加密需要额外的函数：\n HENCRYPT(hk, plaintext)：此函数返回使用头部密钥 hk 对明文 plaintext 做 AEAD 加密的结果。由于相同的 hk 将重复使用，因此 AEAD 的 nonce 值要么必须是有状态且不重复的值，要么必须是由至少 128 比特的熵生成的不重复的随机值。 HDECRYPT(hk, ciphertext)：此函数返回使用头部密钥 hk 对密文 ciphertext 做 AEAD 解密的结果。如果认证失败，或头部密钥 hk 为空（ None ），则此函数返回 None 。 KDF_RK_HE(rk, dh_out)：此函数将根密钥 rk 及迪菲 - 赫尔曼输出 dh_out 作为 KDF 的输入，并输出三元组：新的根密钥，链密钥，以及下一个头部密钥。  4.3. 状态变量 #  所需额外的状态变量：\n HKs, HKr：发送和接收的头部密钥，均为 32 字节 NHKs, NHKr：发送和接收的下一个头部密钥，均为 32 字节  以下变量的定义有所变化：\n MKSKIPPED：已跳过的消息密钥的字典，由头部密钥和消息编号索引。若保存了过多的元素则发生异常。  4.4. 初始化 #  必须使用一些额外的共享密钥以初始化头部密钥：\n Alice 的发送头部密钥和 Bob 的下一个接收头部密钥必须设置为相同的值，以便 Alice 的第一条消息能触发 Bob 执行一次 DH 棘轮步进。 Alice 的下一个接收头部密钥和 Bob 的下一个发送头部密钥必须设置为相同的值，以便在 Bob 的首次 DH 棘轮步进之后，Bob 的下一条消息能触发 Alice 执行一次 DH 棘轮步进。  一旦 Alice 和 Bob 协商好了 SK 、Bob 的棘轮公钥及上述额外的值，Alice 调用 RatchetInitAliceHE() ，而 Bob 调用 RatchetInitBobHE() ：\ndef RatchetInitAliceHE(state, SK, bob_dh_public_key, shared_hka, shared_nhkb): state.DHRs = GENERATE_DH() state.DHRr = bob_dh_public_key state.RK, state.CKs, state.NHKs = KDF_RK_HE(SK, DH(state.DHRs, state.DHRr)) state.CKr = None state.Ns = 0 state.Nr = 0 state.PN = 0 state.MKSKIPPED = {} state.HKs = shared_hka state.HKr = None state.NHKr = shared_nhkb def RatchetInitBobHE(state, SK, bob_dh_key_pair, shared_hka, shared_nhkb): state.DHRs = bob_dh_key_pair state.DHRr = None state.RK = SK state.CKs = None state.CKr = None state.Ns = 0 state.Nr = 0 state.PN = 0 state.MKSKIPPED = {} state.HKs = None state.NHKs = shared_nhkb state.HKr = None state.NHKr = shared_hka 4.5. 加密消息 #  调用 RatchetEncryptHE() 以加密带头部加密的消息：\ndef RatchetEncryptHE(state, plaintext, AD): state.CKs, mk = KDF_CK(state.CKs) header = HEADER(state.DHRs, state.PN, state.Ns) enc_header = HENCRYPT(state.HKs, header) state.Ns += 1 return enc_header, ENCRYPT(mk, plaintext, CONCAT(AD, enc_header)) 4.6. 解密消息 #  调用 RatchetDecryptHE() 以解密带头部加密的消息：\ndef RatchetDecryptHE(state, enc_header, ciphertext, AD): plaintext = TrySkippedMessageKeysHE(state, enc_header, ciphertext, AD) if plaintext != None: return plaintext header, dh_ratchet = DecryptHeader(state, enc_header) if dh_ratchet: SkipMessageKeysHE(state, header.pn) DHRatchetHE(state, header) SkipMessageKeysHE(state, header.n) state.CKr, mk = KDF_CK(state.CKr) state.Nr += 1 return DECRYPT(mk, ciphertext, CONCAT(AD, enc_header)) def TrySkippedMessageKeysHE(state, enc_header, ciphertext, AD): for ((hk, n), mk) in state.MKSKIPPED.items(): header = HDECRYPT(hk, enc_header) if header != None and header.n == n: del state.MKSKIPPED[hk, n] return DECRYPT(mk, ciphertext, CONCAT(AD, enc_header)) return None def DecryptHeader(state, enc_header): header = HDECRYPT(state.HKr, enc_header) if header != None: return header, False header = HDECRYPT(state.NHKr, enc_header) if header != None: return header, True raise Error() def SkipMessageKeysHE(state, until): if state.Nr + MAX_SKIP \u0026lt; until: raise Error() if state.CKr != None: while state.Nr \u0026lt; until: state.CKr, mk = KDF_CK(state.CKr) state.MKSKIPPED[state.HKr, state.Nr] = mk state.Nr += 1 def DHRatchetHE(state, header): state.PN = state.Ns state.Ns = 0 state.Nr = 0 state.HKs = state.NHKs state.HKr = state.NHKr state.DHRr = header.dh state.RK, state.CKr, state.NHKr = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr)) state.DHRs = GENERATE_DH() state.RK, state.CKs, state.NHKs = KDF_RK_HE(state.RK, DH(state.DHRs, state.DHRr)) 5.1. 与 X3DH 集成 #  双棘轮算法可与 X3DH 密钥协商协议 1 集成。双棘轮算法将 X3DH 协商好的会话密钥 SK 作为初始根密钥，扮演「后 X3DH」协议的角色。\n以下 X3DH 的输出将用于双棘轮算法：\n X3DH 输出的 SK 作为双棘轮算法初始化所需的 SK 输入（参见第 3.3 节）。 X3DH 输出的 AD 作为双棘轮算法加解密所需的 AD 输入（参见第 3.4 节及第 3.5 节）。 Bob 从 X3DH 输出的已签名的预共享密钥（ SPKB ）作为双棘轮算法初始化所需的 Bob 的初始棘轮公钥（及对应的密钥对）。  使用 Alice 的初始发送链加密的所有双棘轮消息都可认为是 X3DH 的「初始密文」。为了处理可能发生的消息丢失或乱序，推荐的模型是 Alice 不停地发送前附相同 X3DH 初始消息的双棘轮消息，直到她接收到 Bob 的首条双棘轮响应消息为止。\n5.2. 推荐的密码学算法 #  推荐使用以下算法实例化第 3.1 节中的密码学函数：\n  GENERATE_DH()：此函数推荐使用 Curve25519 或 Curve448 椭圆曲线 7 生成密钥对。\n  DH(dh_pair, dh_pub)：此函数推荐返回 7 中定义的 X25519 或 X448 函数的输出。没必要检查无效的公钥。\n  KDF_RK(rk, dh_out)：此函数推荐使用 SHA-256 或 SHA-5128 的 HKDF3 实现，并使用 rk 作为 HKDF 的 盐（salt） 、dh_out 作为 HKDF 的 输入密钥材料（input key material） 及特定于应用的字节序列作为 HKDF 的 信息（info） 。信息（info） 的值应该与应用中其它 HKDF 使用的值不同。\n  KDF_CK(ck)：此函数推荐使用 SHA-256 或 SHA-5128 的 HMAC2 实现，并使用 ck 作为 HMAC 的密钥，使用不同的常数作为输入生成不同的输出（例如，使用单一字节 0x01 作为输入生成消息密钥，单一字节 0x02 作为输入生成下一个链密钥）。\n  ENCRYPT(mk, plaintext, associated_data)：此函数推荐使用基于 SIV 或基于 CBC 与 HAMC 的组合 59 的 AEAD 加密方案实现。这些方案可避免密钥被多次重复使用。基于 CBC 与 HAMC 的具体推荐方案如下：\n HKDF 与 SHA-256 或 SHA-512 一起使用以生成 80 字节的输出。HKDF 的 盐（salt） 设置为与哈希输出等长的零填充字节序列。HKDF 的 输入密钥材料（input key material） 设置为 mk 。HKDF 的 信息（info） 设置为特定于应用的字节序列且与应用中其它 HKDF 使用的值不同。 HKDF 的输出拆分成三个部分：32 字节的加密密钥，32 字节的认证密钥，以及 16 字节的初始向量（IV）。 明文使用 CBC 模式、带 PKCS#7 填充的 AES-256 算法，使用上一步生成的加密密钥和初始向量（IV）加密 1011。 HMAC 使用认证密钥及上述相同的哈希函数 2 计算得到。HMAC 的输入由关联数据 associated_data 附加在密文前面组成。HAMC 的输出附加在密文后面。    6.1. 安全删除 #  双棘轮算法的设计可避免攻击者记录加密消息并在后继的时间攻破发送者或接收者。但若攻击者获得了设备的底层读取权限并将已删除的明文或密钥从其中恢复，则此安全性不再有效。从存储介质中恢复已删除的数据是个非常复杂的话题，已超出本文的讨论范围。\n6.2. 从泄露中恢复 #  假如被动监听者攻破了会话的一方或双方并观察其加密消息，DH 棘轮的设计保证了从泄露中恢复的安全性。尽管如此，若密钥或设备完整性被攻破将对后继通信的安全产生毁灭性的后果。例如：\n 攻击者可使用被攻破的密钥以伪装成被攻破方（比如，将被攻破方的私钥用于 X3DH 以创建新的会话）。 攻击者可通过持续主动的中间人攻击使用自己的棘轮密钥替换会话中的棘轮密钥，以持续监听被攻破的会话。 攻击者可修改被攻破方的随机数生成器（RNG）使得后继生成的棘轮私钥可预测。  如果某一方怀疑自己的密钥或设备被攻破，必须立即将其更换。\n6.3. 密码学分析与棘轮公钥 #  由于所有的 DH 棘轮计算都混入到根密钥之中，所以一个能使用被动密钥学分析解密会话的攻击者，如果没有观察到某些棘轮公钥，则有可能无法继续解密。\n这当然不是针对密码学分析的可靠对策。如果在会话依赖的任何密码学算法中发现了弱点，对应的会话应该被丢弃，并使用更强的密码学算法创建新的会话。\n6.4. 已跳过的消息密钥的删除 #  保存已跳过的消息密钥引入了如下风险：\n 恶意发送者可使接收者存储大量的已跳过的消息密钥，可能因过于消耗存储空间而导致拒绝服务。 丢失的消息即使未到达接收者也可以被攻击者捕获（并记录）。攻击者可在后继时刻通过获取跳过的消息密钥来攻破对应的接收者。  为降低第一种风险，通信双方应为每个会话设置合理的已跳过消息密钥的数目上限（例如 1000）。为降低第二种风险，通信双方应在某个合适的时间间隔后删除已跳过的消息密钥。删除操作可由定时器触发，或由事件计数触发（事件可以是接收到消息、DH 棘轮步进，等等）。\n6.5. 推迟新棘轮密钥的生成 #  每次 DH 棘轮步进过程中，会生成新的棘轮密钥对和发送链。由于发送链暂时不需使用，这些步骤可推迟到即将发送新消息时完成。这样可通过缩短棘轮密钥的生命周期而轻微地提高安全性，而代价是增加一些复杂性。\n6.6. 认证标签的截断 #  如果 ENCRYPT() 函数使用第 5.2 节中描述的 CBC 和 HMAC 实现，那么将 HMAC 的最终输出截断到 128 比特以减小消息长度是可接受的。尽管将其进一步截断也是可接受的，但需要仔细地分析。但任何情况下都不应将 HAMC 的最终输出截断到小于 64 比特。\n如果 ENCRYPT() 函数使用不同的方式实现，那么截断操作可能需要更复杂的分析且不推荐截断。\n6.7. 指纹信息的实现 #  如果本协议用于匿名双方的设定，需要特别注意所有场景下的实现必须一致。\n在匿名场景下，建议实现时精确遵循第 3 节及第 4 节中的算法。同时建议实现时对于各方使用相同的保存已跳过消息密钥的数目上限，以及相同的已跳过消息密钥删除策略。删除策略应该基于确定的事件（例如接收到消息），而不应基于时间。\n本文自发布之日起进入公共领域。\n本算法由 Trevor Perrin 及 Moxie Marlinspike 设计。\n迪菲 - 赫尔曼棘轮的概念来自 Nikita Borisov、Ian Goldberg 和 Eric Brewer 的 OTR 协议 12。\n对称密钥棘轮是一个旧有的概念 1314，在最近的 SCIMP、MinimaLT 等协议 151617 中均有使用。\n术语「棘轮」用于表示前向安全的密钥更新由 Adam Langley 在 Pond 协议 18 中引入。\n感谢 Michael Rogers 和 Adam Back 在邮件列表中的讨论 19。\n感谢 Adam Langley 关于改进接收算法的讨论。\n本协议及相似协议的安全性已由 Katriel Cohn-Gordon、Cas Cremers、Benjamin Dowling、Luke Garratt 及 Douglas Stebila 完成分析 2021。\n感谢 Tom Ritter、Joseph Bonneau、Ximin Luo、Yan Zhu、Samuel Neves、Raphael Arias 及 David J. Wu 关于编辑方向的反馈。\n"});})();